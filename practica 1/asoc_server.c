/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "asoc_io.h"
#include "asoc.h"

NodoLista * primeroLista = NULL;

int listaCargada = FALSE;
int grabarLista = FALSE;

/*
 * Crea un NodoDiccionario con la pareja <clave,valor>
 * pasada por parametro
 *
 * Devuelve el nodo creado
 */
NodoDiccionario* crearNodoDiccionario(char * clave, char* valor){
	NodoDiccionario* nodo = (NodoDiccionario*) malloc(sizeof(NodoDiccionario));
	if(nodo != NULL){
		nodo->clave = strdup(clave);
		nodo->valor = strdup(valor);
		nodo->sig = NULL;
	}
	return nodo;
}

/*
 * Crea un NodoLista con el id pasado por parametros, y
 * luego añade un NodoDiccionario a dicha lista.
 *
 * Devuelve el nodo creado
 */
NodoLista * crearNodoLista(int id, char * clave, char* valor){
	NodoLista * nodo = (NodoLista*) malloc(sizeof(NodoLista));
	if(nodo != NULL){
		nodo->id = id;
		nodo->diccionario = crearNodoDiccionario(clave, valor);
		if(nodo->diccionario == NULL){
			return NULL;
		}
		nodo->sig = NULL;
	}
	return nodo;
}

/*
 * Borra el NodoLista identificado por id
 * (Cuidado porque borra el diccionario que contiene dicho nodo).
 */
void borrarNodoLista(int id){
	if(primeroLista != NULL){
		NodoLista * it = primeroLista;
		NodoLista * ant = NULL;
		int encontrado = FALSE;
		
		if(it->id == id){
			primeroLista = it->sig;
			it->sig = NULL;
			if(it->diccionario != NULL){
				xdr_free((xdrproc_t) xdr_NodoDiccionario, (char *) it->diccionario);
				encontrado = TRUE;
			}
		}else{
			do{
				ant = it;
				it = it->sig;
				if(it->id == id){
					ant->sig = it->sig;
					it->sig = NULL;
					if(it->diccionario != NULL){
						xdr_free((xdrproc_t) xdr_NodoDiccionario, (char *) it->diccionario);
					}
					encontrado = TRUE;
				}
			}while(!encontrado && it->sig != NULL);
		}
		
		if(encontrado){	
			free(it);
			it = NULL;
		}
	}
}

/*
 * Busca en la lista, un NodoLista identificado con "id".
 *
 * Devuelve: Un puntero a la lista identificada con "id"
 *			 NULL en caso de que no exista.
 */
NodoLista * buscarID(int id){
	NodoLista * it = primeroLista;
	while(it != NULL){
		if(it->id == id){
			return it;
		}
		it = it->sig;
	}
	return it;
}

/*
 * Busca en un diccionario el NodoDiccionario determinado por clave
 *
 * Devuelve: Un puntero al diccionario identificada con "clave"
 *			 NULL en caso de que no exista.
 */
NodoDiccionario * buscarClave(NodoDiccionario * dic, char * clave){
	NodoDiccionario * it = dic;
	while(it != NULL){
		if(strcmp(it->clave, clave) == 0){
			return it;
		}
		it = it->sig;
	}
	return it;
}

/*
 * Asigna a un NodoDiccionario una pareja <clave, valor>
 *
 * Devuelve: OK si es correcto,
 *			 Sustituido si la clave ya tenia un valor asociado.
 *			 FalloMemoria si no se ha podido crear el nodo.
 */
Estado asignarClaveValor(NodoDiccionario * nodo, char* clave, char* valor){
	if(nodo != NULL){
		NodoDiccionario * it = nodo;
		NodoDiccionario * ant = NULL;
		
		do{
			ant = it;
			it = it->sig;
			if(strcmp(ant->clave, clave) == 0){
				free(ant->valor);
				ant->valor = strdup(valor);
				return Sustituido;
			}
		}while(it != NULL);
		
		//Si llega aqui, la clave no se ha encontrado,
		// por tanto se añade uno nuevo
		ant->sig = crearNodoDiccionario(clave, valor);
		if(ant->sig == NULL){
			return FalloMemoria;
		}else{
			return OK;
		}		
	}else{
		return FalloMemoria;
	}
}

/*
 * Duplica el contenido de un diccionario.
 *
 * Devuelve un puntero apuntando al diccionario nuevo.
 */
NodoDiccionario * duplicarDiccionario(NodoDiccionario * nodo){
	/*   No hace falta esta función pq la hace SUNRPC solo   */
	/* 
	NodoDiccionario * copia = NULL;
	if(nodo != NULL){
		NodoDiccionario * it = nodo;
		copia = crearNodoDiccionario(it->clave, it->valor);
		NodoDiccionario * it_copia = copia;
		while(it->sig != NULL){
			it = it->sig;
			it_copia->sig = crearNodoDiccionario(it->clave, it->valor);
			it_copia = it_copia->sig;
		}
	}
	return copia;
	*/
	return nodo;
}

/*
 * Funciones solicitadas por el cliente.
 */

Estado *
ponerasociacion_1_svc(int id, char *clave, char *valor,  struct svc_req *rqstp)
{
	if(!listaCargada){
		listaCargada = TRUE;
		recuperarLista();
		grabarLista = TRUE;
	}
	static Estado result;
	
	if(primeroLista == NULL){
		primeroLista = crearNodoLista(id, clave, valor);
		if(primeroLista == NULL){
			result = FalloMemoria;
		}else{
			result = OK;
		}
	}else{
		NodoLista * it = buscarID(id);
		if(it == NULL){
			it = crearNodoLista(id, clave, valor);
			if(it == NULL){
				result = FalloMemoria;
			}else{
				result = OK;
				it->sig = primeroLista;
				primeroLista = it;
			}
		}/*else if (it->diccionario == NULL){
			it->diccionario = crearNodoDiccionario(clave, valor);
			if(it->diccionario == NULL){
				result = FalloMemoria;
			}else{
				result = OK;
			}
		}*/else{
			result = asignarClaveValor(it->diccionario, clave, valor);
		}
	}
	
	if(result == OK && grabarLista){
		guardarLista(primeroLista);
	}
	
	return &result;
}

ResultadoBusqueda *
obtenerasociacion_1_svc(int id, char * clave,  struct svc_req *rqstp)
{
	if(!listaCargada){
		listaCargada = TRUE;
		recuperarLista();
		grabarLista = TRUE;
	}
	static ResultadoBusqueda  result;
	
	result.s = NoEncontrado;
	result.ResultadoBusqueda_u.valor = NULL;
	
	NodoLista * nLista = buscarID(id);
	if(nLista != NULL){
	
		NodoDiccionario * nDic = buscarClave(nLista->diccionario, clave);
		if(nDic != NULL){
			result.s = OK;
			result.ResultadoBusqueda_u.valor = strdup(nDic->valor);
		}
	}
	return &result;
}

Estado *
borrarasociacion_1_svc(int id, char *clave,  struct svc_req *rqstp)
{
	if(!listaCargada){
		listaCargada = TRUE;
		recuperarLista();
		grabarLista = TRUE;
	}
	static Estado  result;

	result = NoEncontrado;
	
	NodoLista * nLista = buscarID(id);
	if(nLista != NULL){ //si nLista es nulo devuelve NoEncontrado
		NodoDiccionario * it = nLista->diccionario;
		NodoDiccionario * ant = NULL;
		// it no puede ser null porque si no se hubiera
		// borrado el nodo lista
		if(strcmp(it->clave, clave) == 0){
			nLista->diccionario = it->sig;
			it->sig = NULL;
			xdr_free((xdrproc_t) xdr_NodoDiccionario, (char *) it);
			result = OK;
		}else{
			do{
				ant = it;
				it = it->sig;
				if(strcmp(it->clave, clave) == 0){
					ant->sig = it->sig;
					it->sig = NULL;
					xdr_free((xdrproc_t) xdr_NodoDiccionario, (char *) it);
					result = OK;
				}
			}while(it->sig != NULL && result != OK);
		}
		
		if(nLista->diccionario == NULL){
			borrarNodoLista(id);
		}
	}
	
	if(result == OK && grabarLista){
		guardarLista(primeroLista);
	}
	
	return &result;
}

ResultadoEnumerar *
enumerar_1_svc(int id,  struct svc_req *rqstp)
{
	if(!listaCargada){
		listaCargada = TRUE;
		recuperarLista();
		grabarLista = TRUE;
	}
	static ResultadoEnumerar  result;

	result.s = NoEncontrado;
	result.ResultadoEnumerar_u.diccionario = NULL;
	
	NodoLista * lista = buscarID(id);
	
	if(lista != NULL){
		result.s = OK;
		result.ResultadoEnumerar_u.diccionario = duplicarDiccionario(lista->diccionario);
	}

	return &result;
}
